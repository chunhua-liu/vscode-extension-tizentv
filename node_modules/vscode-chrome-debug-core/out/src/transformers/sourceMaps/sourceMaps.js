/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
/* tslint:disable */
var Path = require('path');
var URL = require('url');
var FS = require('fs');
var MozSourceMap = require('source-map');
var PathUtils = require('./pathUtilities');
var utils = require('../../utils');
var logger = require('../../logger');
var SourceMaps = (function () {
    function SourceMaps(webRoot) {
        this._generatedToSourceMaps = {}; // generated -> source file
        this._sourceToGeneratedMaps = {}; // source file -> generated
        this._webRoot = webRoot;
    }
    SourceMaps.prototype.MapPathFromSource = function (pathToSource) {
        var map = this._findSourceToGeneratedMapping(pathToSource);
        if (map)
            return map.generatedPath();
        return null;
        ;
    };
    SourceMaps.prototype.MapFromSource = function (pathToSource, line, column) {
        var map = this._findSourceToGeneratedMapping(pathToSource);
        if (map) {
            line += 1; // source map impl is 1 based
            var mr = map.generatedPositionFor(pathToSource, line, column);
            if (typeof mr.line === 'number') {
                if (SourceMaps.TRACE)
                    console.error(Path.basename(pathToSource) + " " + line + ":" + column + " -> " + mr.line + ":" + mr.column);
                return { path: map.generatedPath(), line: mr.line - 1, column: mr.column };
            }
        }
        return null;
    };
    SourceMaps.prototype.MapToSource = function (pathToGenerated, line, column) {
        var map = this._generatedToSourceMaps[pathToGenerated];
        if (map) {
            line += 1; // source map impl is 1 based
            var mr = map.originalPositionFor(line, column);
            if (mr.source) {
                if (SourceMaps.TRACE)
                    console.error(Path.basename(pathToGenerated) + " " + line + ":" + column + " -> " + mr.line + ":" + mr.column);
                return { path: mr.source, line: mr.line - 1, column: mr.column };
            }
        }
        return null;
    };
    SourceMaps.prototype.AllMappedSources = function (pathToGenerated) {
        var map = this._generatedToSourceMaps[pathToGenerated];
        return map ? map.sources : null;
    };
    SourceMaps.prototype.ProcessNewSourceMap = function (pathToGenerated, sourceMapURL) {
        return this._findGeneratedToSourceMapping(pathToGenerated, sourceMapURL).then(function () { });
    };
    //---- private -----------------------------------------------------------------------
    SourceMaps.prototype._findSourceToGeneratedMapping = function (pathToSource) {
        if (pathToSource) {
            if (pathToSource in this._sourceToGeneratedMaps) {
                return this._sourceToGeneratedMaps[pathToSource];
            }
            for (var key in this._generatedToSourceMaps) {
                var m = this._generatedToSourceMaps[key];
                if (m.doesOriginateFrom(pathToSource)) {
                    this._sourceToGeneratedMaps[pathToSource] = m;
                    return m;
                }
            }
        }
        return null;
    };
    /**
     * pathToGenerated - an absolute local path or a URL.
     * mapPath - a path relative to pathToGenerated.
     */
    SourceMaps.prototype._findGeneratedToSourceMapping = function (pathToGenerated, mapPath) {
        var _this = this;
        if (!pathToGenerated) {
            return Promise.resolve(null);
        }
        if (pathToGenerated in this._generatedToSourceMaps) {
            return Promise.resolve(this._generatedToSourceMaps[pathToGenerated]);
        }
        if (mapPath.indexOf("data:application/json") >= 0) {
            logger.log("SourceMaps.findGeneratedToSourceMapping: Using inlined sourcemap in " + pathToGenerated);
            // sourcemap is inlined
            var pos = mapPath.lastIndexOf(',');
            var data = mapPath.substr(pos + 1);
            try {
                var buffer = new Buffer(data, 'base64');
                var json = buffer.toString();
                if (json) {
                    var map = new SourceMap(pathToGenerated, json, this._webRoot);
                    this._generatedToSourceMaps[pathToGenerated] = map;
                    return Promise.resolve(map);
                }
            }
            catch (e) {
                logger.log("SourceMaps.findGeneratedToSourceMapping: exception while processing data url (" + e.stack + ")");
            }
            return null;
        }
        // if path is relative make it absolute
        if (!Path.isAbsolute(mapPath)) {
            if (Path.isAbsolute(pathToGenerated)) {
                // runtime script is on disk, so map should be too
                mapPath = PathUtils.makePathAbsolute(pathToGenerated, mapPath);
            }
            else {
                // runtime script is not on disk, construct the full url for the source map
                var scriptUrl = URL.parse(pathToGenerated);
                mapPath = scriptUrl.protocol + "//" + scriptUrl.host + Path.dirname(scriptUrl.pathname) + "/" + mapPath;
            }
        }
        return this._createSourceMap(mapPath, pathToGenerated).then(function (map) {
            if (!map) {
                var mapPathNextToSource = pathToGenerated + ".map";
                if (mapPathNextToSource !== mapPath) {
                    return _this._createSourceMap(mapPathNextToSource, pathToGenerated);
                }
            }
            return map;
        }).then(function (map) {
            if (map) {
                _this._generatedToSourceMaps[pathToGenerated] = map;
            }
            return map || null;
        });
    };
    SourceMaps.prototype._createSourceMap = function (mapPath, pathToGenerated) {
        var _this = this;
        var contentsP;
        if (utils.isURL(mapPath)) {
            logger.log("SourceMaps.createSourceMap: Downloading sourcemap file from " + mapPath);
            contentsP = utils.getURL(mapPath).catch(function (e) {
                logger.log("SourceMaps.createSourceMap: Could not download map from " + mapPath);
                return null;
            });
        }
        else {
            contentsP = new Promise(function (resolve, reject) {
                logger.log("SourceMaps.createSourceMap: Reading local sourcemap file from " + mapPath);
                FS.readFile(mapPath, function (err, data) {
                    if (err) {
                        logger.log("SourceMaps.createSourceMap: Could not read map from " + mapPath);
                        resolve(null);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        }
        return contentsP.then(function (contents) {
            if (contents) {
                try {
                    // Throws for invalid contents JSON
                    return new SourceMap(pathToGenerated, contents, _this._webRoot);
                }
                catch (e) {
                    logger.log("SourceMaps.createSourceMap: exception while processing sourcemap: " + e.stack);
                    return null;
                }
            }
            else {
                return null;
            }
        });
    };
    SourceMaps.TRACE = false;
    SourceMaps.SOURCE_MAPPING_MATCHER = new RegExp("//[#@] ?sourceMappingURL=(.+)$");
    return SourceMaps;
}());
exports.SourceMaps = SourceMaps;
var Bias;
(function (Bias) {
    Bias[Bias["GREATEST_LOWER_BOUND"] = 1] = "GREATEST_LOWER_BOUND";
    Bias[Bias["LEAST_UPPER_BOUND"] = 2] = "LEAST_UPPER_BOUND";
})(Bias || (Bias = {}));
var SourceMap = (function () {
    /**
     * pathToGenerated - an absolute local path or a URL
     * json - sourcemap contents
     * webRoot - an absolute path
     */
    function SourceMap(generatedPath, json, webRoot) {
        logger.log("SourceMap: creating SM for " + generatedPath);
        this._generatedPath = generatedPath;
        var sm = JSON.parse(json);
        var absSourceRoot = PathUtils.getAbsSourceRoot(sm.sourceRoot, webRoot, this._generatedPath);
        // Overwrite the sourcemap's sourceRoot with the version that's resolved to an absolute path,
        // so the work above only has to be done once
        sm.sourceRoot = null; // probably get rid of this._sourceRoot?
        // sm.sources are relative paths or file:/// urls - (or other URLs?) read the spec...
        // resolve them to file:/// urls, using absSourceRoot.
        // note - the source-map library doesn't like backslashes, but some tools output them.
        // Which is wrong? Consider filing issues on source-map or tools that output backslashes?
        // In either case, support whatever works
        this._sources = sm.sources.map(function (sourcePath) {
            // Special-case webpack:/// prefixed sources which is kind of meaningless
            sourcePath = utils.lstrip(sourcePath, 'webpack:///');
            sourcePath = utils.canonicalizeUrl(sourcePath);
            // If not already an absolute path, make it an absolute path with this._absSourceRoot. Also resolves '..' parts.
            if (!Path.isAbsolute(sourcePath)) {
                sourcePath = Path.resolve(absSourceRoot, sourcePath);
            }
            return sourcePath;
        });
        // Rewrite sm.sources to same as this._sources but forward slashes and file url
        sm.sources = this._sources.map(function (sourceAbsPath) {
            // Convert to file: url. After this, it's a file URL for an absolute path to a file on disk with forward slashes.
            return utils.pathToFileURL(sourceAbsPath);
        });
        this._smc = new MozSourceMap.SourceMapConsumer(sm);
    }
    Object.defineProperty(SourceMap.prototype, "sources", {
        /*
         * Return all mapped sources as absolute paths
         */
        get: function () {
            return this._sources;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * the generated file of this source map.
     */
    SourceMap.prototype.generatedPath = function () {
        return this._generatedPath;
    };
    /*
     * returns true if this source map originates from the given source.
     */
    SourceMap.prototype.doesOriginateFrom = function (absPath) {
        return this.sources.some(function (path) { return path === absPath; });
    };
    /*
     * finds the nearest source location for the given location in the generated file.
     */
    SourceMap.prototype.originalPositionFor = function (line, column, bias) {
        if (bias === void 0) { bias = Bias.LEAST_UPPER_BOUND; }
        var mp = this._smc.originalPositionFor({
            line: line,
            column: column,
            bias: bias
        });
        if (mp.source) {
            mp.source = PathUtils.canonicalizeUrl(mp.source);
        }
        return mp;
    };
    /*
     * finds the nearest location in the generated file for the given source location.
     */
    SourceMap.prototype.generatedPositionFor = function (src, line, column, bias) {
        if (bias === void 0) { bias = Bias.LEAST_UPPER_BOUND; }
        src = utils.pathToFileURL(src);
        var needle = {
            source: src,
            line: line,
            column: column,
            bias: bias
        };
        return this._smc.generatedPositionFor(needle);
    };
    return SourceMap;
}());

//# sourceMappingURL=sourceMaps.js.map
